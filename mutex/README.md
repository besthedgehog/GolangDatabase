# Mutex (Mutual Exclusion)

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// SafeCounter — структура с защитой
type SafeCounter struct {
	mu    sync.Mutex // Сам замок
	likes int        // Общий ресурс
}

// Inc — метод для увеличения счетчика
func (c *SafeCounter) Inc() {
	// 1. БЛОКИРУЕМ ДОСТУП
	// Как только одна горутина прошла эту строку,
	// все остальные встают в очередь и ЖДУТ здесь.
	c.mu.Lock()

	// 2. ВСЕГДА используем defer для разблокировки
	// Это гарантирует, что замок откроется, даже если функция упадет с ошибкой (panic).
	// Если забыть Unlock — программа зависнет навечно (Deadlock).
	defer c.mu.Unlock()

	// 3. КРИТИЧЕСКАЯ СЕКЦИЯ
	// Безопасно меняем данные. Сюда заходит только один поток одновременно.
	c.likes++
}

// Value — метод чтобы узнать текущее значение
func (c *SafeCounter) Value() int {
	c.mu.Lock()         // Даже чтобы просто прочитать,
	defer c.mu.Unlock() // нужно закрыть дверь, чтобы никто не менял данные в этот момент.
	return c.likes
}

func main() {
	counter := SafeCounter{}
	var wg sync.WaitGroup

	// Запускаем 1000 горутин, каждая ставит лайк
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			// Имитация бурной деятельности
			time.Sleep(time.Millisecond)

			counter.Inc() // Пытаемся зайти в туалет
		}()
	}

	wg.Wait() // Ждем всех
	fmt.Println("Всего лайков:", counter.Value())
}
```

__Как это работает:__

1) Мы создаем sync.Mutex внутри структуры. Обычно его называют mu.

2) В методе Inc() мы вызываем c.mu.Lock().

    * Первая горутина проходит свободно.

    * Вторая, третья и сотая горутины, дойдя до этой строки, останавливаются и спят.

3) Первая горутина делает c.likes++.

4) Срабатывает defer c.mu.Unlock(). Замок открывается.

5) Просыпается одна следующая горутина из очереди, захватывает замок и заходит.


__Важные правила Мьютекса:__

1) Всегда Unlock: Если ты сделал Lock, ты обязан сделать Unlock. Иначе программа зависнет навсегда (все будут ждать вечно). Поэтому лучше использовать defer

2) Не копируй Мьютекс: Если ты передаешь структуру с мьютексом в функцию, передавай её по указателю (*SafeCounter), а не по значению. Если скопировать структуру, скопируется и замок (в закрытом состоянии или открытом), и они станут двумя разными замками. Защита сломается.

3) Lock защищает код, а не данные: Мьютекс сам по себе не "оборачивает" переменную likes. Он просто создает "узкое место" в коде. Ты сам как программист должен следить, чтобы везде, где ты трогаешь likes, стоял Lock.

То есть за мьютекосом нужно следить самому, потому что вот так тоже сработает

```go
// Обходим защиту
	counter.Inc()
	fmt.Println(counter.Value()) // 1001
```
